import java.io.*;
import java.util.StringTokenizer;
import javax.swing.*;
import java.util.Arrays;
import java.awt.*;

/**
 * ---------------------------------------------------------------------
 * Warehouse Application
 * Constructs the Main Screen of the application
 * @author Alvaro Morales
 * @date 04/06/2010
 * @school Markham College
 * @IDE Eclipse SDK
 * @computer IBM ThinkPad R52
 * ---------------------------------------------------------------------
 */
public class MainScreen extends javax.swing.JFrame {

	/**
	 * Utilities that will be accessed throughout the application
	 */

	/**
	 * The Binary Tree of Item indexes by name
	 */
	public static IndexBTree nameIndexTree;

	/**
	 * The Binary Tree of Item indexes by code
	 */
	public static IndexBTree codeIndexTree;

	/**
	 * The array of Item groups
	 */
	public static Group[] groups;

	/**
	 * The array of Item unit of measurements (UMs)
	 */
	public static UM[] umArray;

	/**
	 * The available locations in the warehouse
	 */
	public static WarehouseLocations locations;

	/**
	 * The user that logged in
	 */
	private User user;

	/**
	 * The Main Screen's contentPane
	 */
	public static Container contentPane;

	/**
	 * Start of the code generated using CloudGarden's Jigloo SWT/Swing GUI Builder
	 */

	{
		//Set Look & Feel
		try {
			javax.swing.UIManager.setLookAndFeel("javax.swing.plaf.metal.MetalLookAndFeel");
		} catch(Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * GUI components generated by Jigloo
	 */
	
	private WarehouseMenuBar mnuMain;
	private JPanel pnlMainScreen;
	private WarehouseToolbar tlbMain;

	/**
	 * Constructs a new MainScreen object
	 * @param user - the user that logged in
	 */
	public MainScreen(User user) {
		super();
		this.user = user;
		this.contentPane = getContentPane();
		populateUtilities();
		initGUI(user);
	}

	/**
	 * Method generated by Jigloo to initialize GUI components
	 */
	private void initGUI(User user) {
		try {
			this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
			this.setTitle("Warehouse Application");
			this.setIconImage(new ImageIcon(getClass().getClassLoader().getResource(ApplicationConstants.WAREHOUSE_LOGO)).getImage());
			this.setResizable(false);
			this.setFocusTraversalKeysEnabled(false);
			this.setLocation(new java.awt.Point(100, 100));
			{
				ChangeScreen.setBlankScreen(user);
			}
			{
				mnuMain = new WarehouseMenuBar(user, this);
				setJMenuBar(mnuMain);
			}
			pack();
			this.setSize(809, 577);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * End of the code generated using CloudGarden's Jigloo SWT/Swing GUI Builder
	 */

	/**
	 * Gets the user that logged in
	 * @return the user that logged in
	 */
	public User getUser(){
		return user;
	}

	/**
	 * Initializes the application's utilities
	 */
	public void populateUtilities(){
		MainScreen.groups = getGroups();	//Populate Groups
		MainScreen.umArray = getUMs();		//Populate Units of Measurement (UMs)
		MainScreen.locations = new WarehouseLocations();	//Populate the Locations
		MainScreen.codeIndexTree = new IndexBTree();
		MainScreen.nameIndexTree = new IndexBTree();
		populateBinaryTrees();
	}

	/**
	 * Reads the Group file to get an array of Groups
	 * @return an array of Groups
	 * @mastery achieves HL mastery factor 9 by parsing the Groups text file to obtain an array of Groups
	 */
	public Group[] getGroups(){
		try{
			File file = new File(ApplicationConstants.GROUPS_FILE);
			FileReader reader = new FileReader(file);
			BufferedReader buff = new BufferedReader(reader);

			boolean eof = false;		//stores whether the end of the file has been reached

			int numberOfGroups = 0;

			while(!eof){
				String line = buff.readLine();
				if (line == null){
					eof = true;		//the end of the file has been reached
				} else {
					numberOfGroups++;
				}
			}

			Group[] groups = new Group[numberOfGroups];

			reader.close();
			buff.close();

			FileReader reader2 = new FileReader(file);
			BufferedReader buff2 = new BufferedReader(reader2);

			for (int i = 0;i<numberOfGroups;i++){
				String line = buff2.readLine();
				groups[i] = readGroup(line);
			}

			return groups;

		} catch(Exception e){
			return null;
		}
	}

	/**
	 * Returns a Group object from a tokenized String
	 * @param line - a tokenized String
	 * @return a Group object from that String
	 */
	public Group readGroup(String line){
		StringTokenizer tokenizer = new StringTokenizer(line, "|");
		String code = tokenizer.nextToken();

		while(code.startsWith("0")){
			code = code.substring(1, code.length());
		}

		short codeValue = new Integer(code).shortValue();
		String name = tokenizer.nextToken();
		return new Group(codeValue,name);
	}

	/**
	 * Reads the Group file to get an array of Groups
	 * @return an array of Groups
	 */
	public UM[] getUMs(){
		try{
			File file = new File(ApplicationConstants.UM_FILE);
			FileReader reader = new FileReader(file);
			BufferedReader buff = new BufferedReader(reader);

			boolean eof = false;		//stores whether the end of the file has been reached

			int numberOfGroups = 0;

			while(!eof){
				String line = buff.readLine();
				if (line == null){
					eof = true;		//the end of the file has been reached
				} else {
					numberOfGroups++;
				}
			}

			UM[] umArray = new UM[numberOfGroups];

			FileReader reader2 = new FileReader(file);
			BufferedReader buff2 = new BufferedReader(reader2);

			for (int i = 0;i<numberOfGroups;i++){
				String line = buff2.readLine();
				umArray[i] = readUM(line);
			}

			return umArray;

		} catch(Exception e){
			return null;
		}
	}

	/**
	 * Returns a UM object from a tokenized String
	 * @param line - a tokenized String
	 * @return a UM object from that String
	 */
	public UM readUM(String line){
		StringTokenizer tokenizer = new StringTokenizer(line, "|");
		String code = tokenizer.nextToken();

		while(code.startsWith("0")){
			code = code.substring(1, code.length());
		}

		short codeValue = new Integer(code).shortValue();
		String name = tokenizer.nextToken();
		return new UM(codeValue,name);
	}

	/**
	 * Populates the binary trees of Item Indexes by code and name
	 */
	public void populateBinaryTrees(){
		Index[] codeIndexes = readIndexes(new File(ApplicationConstants.CODE_INDEX_FILE));
		Index[] nameIndexes = readIndexes(new File(ApplicationConstants.NAME_INDEX_FILE));

		createIndexBinaryTree(codeIndexes, MainScreen.codeIndexTree);
		createIndexBinaryTree(nameIndexes, MainScreen.nameIndexTree);

	}

	/**
	 * Method makes a recursive call to createNameIndexBTree() to make sure that the items 
	 * of the ordered array are added in a way so that the binary tree of indexes is properly balanced
	 * @param indexes - the ordered array of either code or name indexes
	 * @param tree - the tree of indexes
	 */
	public void createIndexBinaryTree(Index[] indexes, IndexBTree tree){
		createIndexBinaryTree(indexes, tree, 0, indexes.length);
	}

	/**
	 * Method is called recursively to make sure that the items of the ordered array are 
	 * added in a way so that the binary tree of indexes is properly balanced
	 * @param indexes - the ordered array of either code or name indexes
	 * @param tree - the tree of indexes
	 * @param start - a pointer to the start of the array block
	 * @param finish - a pointer to the end of the array block
	 */
	private void createIndexBinaryTree(Index[] indexes, IndexBTree tree, int start, int finish){
		int mid = ((finish-start)/2) + start;
		int size = finish - start;

		if(mid > indexes.length-1){
			return;
		} else if (size == 0){
			tree.insertIndex(new IndexTNode(indexes[mid]));
		} else {
			tree.insertIndex(new IndexTNode(indexes[mid]));
			createIndexBinaryTree(indexes, tree, start, mid);
			createIndexBinaryTree(indexes, tree, mid+1, finish);

		}
	}

	/**
	 * Returns an ordered array (by field - either code or name) of Indexes
	 * @param file - the Index file
	 * @return an ordered array of Indexes
	 * @mastery achieves SL mastery factor 10 as it is a user defined method with an appropriate object return value
	 */
	public Index[] readIndexes(File file){		
		try{
			FileReader reader = new FileReader(file);
			BufferedReader buff = new BufferedReader(reader);

			boolean eof = false;		//stores if the end of the file (eof) has been reached
			int numberOfRecords = 0;

			/**
			 * @mastery achieves SL mastery factor 6 with the while loop
			 */
			while(!eof){
				String line = buff.readLine();

				/**
				 * @mastery achieves SL mastery factor 4 with the if/else selection block
				 */
				if(line == null){
					eof = true;		//the end of the file has been reached
				} else {
					numberOfRecords++;
				}
			}

			buff.close();

			Index[] indexes = new Index[numberOfRecords];

			FileReader reader2 = new FileReader(file);
			BufferedReader buff2 = new BufferedReader(reader2);

			for(int i=0;i<numberOfRecords;i++){
				String line = buff2.readLine();
				indexes[i] = new Index(line);
			}

			Arrays.sort(indexes);
			buff.close();
			reader.close();
			buff2.close();
			reader2.close();
			
			return indexes;

		} catch (Exception e){
			return null;
		}
	}


}
